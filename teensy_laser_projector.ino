#include <bitset>
#include <numeric> // For std::accumulate
#include <cmath>

// 'img', 128x128px
/**
 * Made with Marlin Bitmap Converter
 * https://marlinfw.org/tools/u8glib/converter.html
 *
 * This bitmap from the file 'pixil-frame-0.bmp'
 */
const unsigned char bitmap[] PROGMEM = {
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000011,B11110000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00011111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000011,B11110000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B00011111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B01111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111000,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B01111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111100,B00000001,B11111111,B10000000,B00000000,B00000111,B11111111,B00000000,B01111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111100,B00000000,B00000000,B00000000,B00000000,B00000111,B11111111,B00000000,B11111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111100,B00000000,B00000000,B00000000,B00000000,B00000111,B11111111,B00000000,B11111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000011,B11111111,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000011,B11111111,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000011,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000111,B11111110,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000011,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00001111,B11111110,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000001,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00001111,B11111110,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000001,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00011111,B11111100,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00111111,B11111100,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000001,B11111111,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B01111111,B11111100,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B11111111,B11000000,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B11111000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B11111111,B11000000,B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B11111000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B01111111,B11100000,B00000000,B00000000,B00000000,B00000000,B00000111,B11111111,B11110000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B01111111,B11100000,B00000000,B00000000,B00000000,B00000000,B00000111,B11111111,B11110000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00111111,B11110000,B00000000,B00000000,B00000000,B00000000,B00001111,B11111111,B11100000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00111111,B11111000,B00000000,B00000000,B00000000,B00000000,B00111111,B11111111,B11000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00011111,B11111100,B00000000,B00000000,B00000000,B00000000,B01111111,B11111111,B10000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00011111,B11111110,B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00001111,B11111111,B00000000,B00000000,B00000000,B00000001,B11111111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00001111,B11111111,B11000000,B00000000,B00000000,B00000011,B11111111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000111,B11111111,B11110000,B00000000,B00000000,B00000111,B11111111,B11111100,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000111,B11111111,B11111110,B00000000,B00000000,B00011111,B11111111,B11111000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000111,B11111111,B11111111,B11100000,B00000000,B00111111,B11111111,B11110000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000011,B11111111,B11111111,B11111111,B10000011,B11111111,B11111111,B11100000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000001,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11100000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000001,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B01111111,B11111111,B11111111,B11111111,B11111111,B11111100,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00111111,B11111111,B11111111,B11111111,B11111111,B11111000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00011111,B11111111,B11111111,B11111111,B11111111,B11100000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00001111,B11111111,B11111111,B11111111,B11111111,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000011,B11111111,B11111111,B11111111,B11111110,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B11111111,B11111111,B11110000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000001,B11111111,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000
};




const unsigned int YRES = 64;//image.height();
const unsigned int XRES  = 128;//image.width();


const bool MONITOR = false;

std::bitset<XRES*YRES> img(0);

const int LASER_OUT = 32;
const int LASER_OUT_2 = 33;
const int PIN_SCAN_SENSOR = A0;
const int PIN_VERT_SENSOR = A5;
const int PIN_PHASESHIFT = A14;
// const int FLASH_IN = 33;


const int N_SIDES = 12;
int faceCount = 0; // increments, counting each face, mod N_SIDES

volatile int led_pot = 0;
volatile bool notSpiking = true;
int lastSpikeTime = 0;
int lastSpikePeriod[N_SIDES];

volatile int ind_pot = 0;
volatile bool notVertSpiking = true;
int lastVertSpikeTime = 0;
int lastVertSpikePeriod = 0;

volatile int timeBeforeDraw = 0;
volatile int drawTime;

int lineStartPhase = 0;
float ellipsePhase = M_PI / 2;

int spikePeriod = 1000;


float ellipseWidth = 30;

int l2_dx = 1;
int l2_dy = 1;


const int awr = 4;
const int analogRange = pow(2, awr);

const int arr = 8;
const int analogReadRange = pow(2,arr);


double average_array(int arr[], int size) {
    if (size <= 0) {
        return 0; // Avoid division by zero or processing empty arrays
    }
    double sum = std::accumulate(arr, arr + size, 0.0);
    return sum / size;
}



void spike_sensor() {
  led_pot = analogRead(PIN_SCAN_SENSOR);
  if (led_pot < 50 && notSpiking) {
    notSpiking = false;
    // add spike period to array, to average out blips
    faceCount = (faceCount+1) % N_SIDES;
    lastSpikePeriod[faceCount] = micros() - lastSpikeTime; // average_array(lastSpikePeriod, N_SIDES);
    lastSpikeTime = micros();
  } else if (led_pot > 140) {
    notSpiking = true;
  }

  ind_pot = analogRead(PIN_VERT_SENSOR);
  if (ind_pot > 50 && notVertSpiking) {
      notVertSpiking = false;
      lastVertSpikePeriod = micros() - lastVertSpikeTime;
      lastVertSpikeTime = micros();
  } else if (ind_pot < 30) {
    notVertSpiking = true;
  }

}

int i, j, i_2, j_2;
float phi;
char receivedChar;

void draw_image() {
  // while (1) {


    drawTime = micros() - timeBeforeDraw;
    timeBeforeDraw = micros();
    // for (size_t i = 0; i < img.size(); ++i) {
    lineStartPhase = analogRead(PIN_PHASESHIFT);

    spike_sensor();
    // spikePeriod = average_array(lastSpikePeriod, N_SIDES);
    spikePeriod = lastSpikePeriod[(faceCount-1) % N_SIDES];
    // calculate the duration of the last drawing cycle




    // draw the image
    i = XRES * (micros() - lastSpikeTime) / spikePeriod;
    phi = 2* M_PI * (micros() - lastVertSpikeTime) / lastVertSpikePeriod;
    j = YRES * 0.5*(1+ std::sin(phi + ellipsePhase));

    i += ellipseWidth * std::cos(phi + ellipsePhase);
    i = int(i + lineStartPhase) % XRES;
    
    if ( i < XRES && j < YRES) {
      digitalWriteFast(LASER_OUT, img[XRES*j + i]);
    }
    i_2 = (i+l2_dx) % XRES;
    j_2 = (j+l2_dy) % YRES;
    if ( i_2 < XRES && j_2 < YRES) {
      digitalWriteFast(LASER_OUT_2, img[XRES*(j_2) + i_2]);
    }

    analogWrite(A10, float(i) / XRES * analogRange);
    analogWrite(A11, float(j) / YRES * analogRange);


    if (ARM_DWT_CYCCNT % 117 == 0) { // only print 1/10 the time

      ellipseWidth = analogRead(A6) * XRES / analogReadRange;
      ellipsePhase = analogRead(A9) * 2*M_PI / analogReadRange;
      l2_dx = analogRead(A7) * XRES / analogReadRange;
      l2_dy = analogRead(A8) * YRES / analogReadRange;
      // if (Serial.available() > 0) {
        // receivedChar = Serial.read();
        // Serial.println("RECEIVED");
        // Serial.println(receivedChar);
        // switch (receivedChar) {
        //   case '+':
        //     ellipseWidth++; break;
        //   case '-':
        //     ellipseWidth--; break;
        //   case 'a':
        //     l2_dx--; break;
        //   case 'd':
        //     l2_dx++; break;
        //   case 'w':
        //     l2_dy++; break;
        //   case 's':
        //     l2_dy--; break;
        // }
        Serial.println(ellipseWidth);
        Serial.println(ellipsePhase);
        Serial.println(l2_dx);
        Serial.println(l2_dy);


      // }
      if (MONITOR) {
    // Serial.println(float(i) / XRES);

      // Serial.print(i);
      // Serial.print(",");
      // Serial.println(j);
      // Serial.println(phi);

      // Serial.print("drawTime:");
      // Serial.print(drawTime);
      // Serial.print(", lastSpikePeriod:");
      // Serial.print(lastSpikePeriod[0]);
      // Serial.print(", spikePeriod:");
      // Serial.print(spikePeriod);
      // Serial.print(", time since spike:");
      // Serial.print(micros() - lastSpikeTime);
      // Serial.print(", column:");
      // Serial.print(i);
      // Serial.print(", spiking:");
      // Serial.print(1-notSpiking);

      // Serial.println(phi);
      Serial.print(", lastVertSpikePeriod:");
      Serial.print(lastVertSpikePeriod);
      Serial.print(", time since vert spike:");
      Serial.print(micros() - lastVertSpikeTime);
      Serial.print(", row:");
      Serial.println(j);
      // Serial.print(", vert spiking:");
      // Serial.println(1-notVertSpiking);
      // Serial.print(", adaptiveDelay: ");
      // Serial.println(adaptiveDelay);
      }
    }
}



void setup() {
  Serial.begin(38400);


// bitmap_image image("img.bmp");
  

  Serial.println("IMAGE:");

  for (uint32_t J = 0; J < YRES; J++) {
    for (uint32_t I = 0; I < XRES; I++){
      // rgb_t colour;

      // image.get_pixel(I, J, colour);
      // Serial.println(J*XRES + I);
      if ((bitmap[(J*XRES + I)/8] >> (I/XRES % 8)) & 1) {
      // if (colour.red >= 111) {
        img[J*XRES + I] = 1;
      }

      Serial.print(img[XRES*J + I]);
    }
    Serial.println();
  }

  pinMode(LASER_OUT, OUTPUT);
  pinMode(LASER_OUT_2, OUTPUT);
  pinMode(PIN_SCAN_SENSOR, INPUT);
  pinMode(PIN_VERT_SENSOR, INPUT);
  pinMode(PIN_PHASESHIFT, INPUT);


  pinMode(A6, INPUT);
  pinMode(A7, INPUT);
  pinMode(A8, INPUT);
  pinMode(A9, INPUT);

  analogReadResolution(arr); // 256
  analogReadAveraging(1); // No averaging

  analogWriteResolution(awr);
  pinMode(A10, OUTPUT);
  pinMode(A11, OUTPUT);
  analogWriteFrequency(A10, (150*1e6) / analogRange);
  analogWriteFrequency(A11, (150*1e6) / analogRange);
}


void loop() {
  draw_image();
}
